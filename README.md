# ENSAE 1A : projet de programmation

Ce dépôt public contient les ressources pour les étudiants pour le projet de programmation 1A sur l'optimisation d'un réseau de livraison. Pour la description du projet lui-même, se référer au PDF sur pamplemousse. 

Ce dépôt contient plusieurs dossiers et fichiers : 
- le dossier `delivery_network` contient le code principal (une base de code pour l'instant, que vous devrez compléter). C'est là qu'est la classe Graph que vous devez implémenter. C'est aussi là que vous mettrez les autres fichiers .py principaux au cours du projet. 
- le dossier 'inputs' contient des jeux de données (graphes et ensembles de trajets) 
- le dossier 'tests' contient les tests unitaires (des exemples, à vous d'en faire d'autres !)
- le fichier `install_graphviz.sh` permet d'installer graphviz sur sspcloud

## Format des fichiers d'input

Le dossier input contient 2 types de fichiers : les fichiers network.x.in ($x \in \{00, 01, 02, 03, 04, 1, ..., 10\}$) qui contiennent les graphes et les fichiers routes.x.in ($x \in \{1, ..., 10\}$) qui contiennent des ensembles de trajets pour les graphes de $x$ correspondant. 

La structure des fichiers network.x.in est la suivante : 
- la première ligne est composée de deux entiers séparés par un espace : le nombre de sommets (n) et le nombre d'arêtes (m)
- les m lignes suivantes représentent chacune une arête et sont composées de 3 ou 4 nombres séparés par des espaces : `ville1 ville2 puissance [distance]`, où `ville1` et `ville2` sont les sommets de l'arête, puissance est la puissance minimale requise pour passer sur l'arête, et distance (optionnel) est la distance entre `ville1` et `ville2` sur l'arête. 

La structure des fichiers routes.x.in est la suivante : 
- la première ligne contient un entier qui correspond aux nombres de trajets dans l'ensemble (T)
- les T lignes suivantes contiennent chacune un trajet sous la forme `ville1 ville2 utilité`, où utilité est le profit acquis si le trajet correspondant est couvert. 

Compte-Rendu 


Compte rendu Projet de Programmation 
 
Partie 1 : Calcul de la puissance minimale d’un trajet 
Pour cette partie, le but était de compléter la classe Graph qui contenait un certain nombre de fonctions qui ont pour but d’arriver au calcul de la puissance minimale nécessaire pour effectuer un trajet. L’idée est de représenter la carte sous forme d’un graphe, avec chaque ville représentée par un sommet, et chaque trajet par une arrête entre deux sommets à laquelle était associé une distance et une puissance. Dans un premier temps, la distance a été laissée de côté et nous nous sommes intéressés au problème simplifié sans la distance. 
Question 1 : Pour cette question, il nous fallait compléter les fonctions s’occupant de représenter la carte sous forme d’un graphe. Ici nous nous sommes intéressés à la méthode add_edge qui ajoute une arrête et ses sommets au graphe. Cette méthode prend comme paramètre les deux sommets de l’arrête à ajouter, sa puissance associée et sa distance (pour le moment par défaut laissée égale à 1). Pour atteindre cet objectif nous avons choisis de procéder de la manière suivante : tout d’abord, pour chacun des deux sommets nous regardons si le sommet est déjà, ou non, présent sur le graphe, s’il ne l’est pas on le rajoute. Puis, pour chacun des nœuds on rajoute l’arrête, en ajoutant à la liste des voisins dudit nœuds un tuple comprenant l’autre nœud, la puissance de l’arrête et sa distance. Nous avons choisi cette méthode car c’est celle qui nous as paru la plus simple et la plus facile à mettre en œuvre. 
Ensuite, nous avons complété la fonction graph_from_file qui s’occupe de créer un graphe à partir d’un fichier. En effet, nous avons à notre disposition des fichiers contenant une liste de sommets et d’arrêtes entre ces sommets, l’objectif est donc de mettre au point une fonction qui lit le fichier et crée le graphe correspondant. Pour cela, nous commençons par lire la première ligne du fichier qui contient le nombre de sommet et le nombre d’arrête. Puis nous créons un graphe avec le nombre de sommet correspondant. À Partir de là, nous effectuons un processus itératif : pour chaque arrête, on lit la ligne du fichier, on récupère les données correspondants (quels sont les sommets reliés et quel est la puissance de l’arrête) puis on applique la méthode précédemment mise au point avec ces paramètres. Nous avons aussi choisi de rajouter le cas où le fichier ne correspondrait pas au format attendu, auquel cas la fonction renvoie un message d’erreur. Ici aussi nous avons choisi cette option qui nous as intuitivement paru la plus simple, et qui nous a satisfait par ses performances.  
Question 2 : L’objet de cette question était de compléter la méthode  connected_components_set qui renvoie une liste des composantes connexes du graphe. L’objectif étant de savoir quels sont les sommets qui sont connectés entre eux, pour plus tard pouvoir trouver les chemins réalisables. Pour ce faire, nous parcourons dans connected_components les différents nœuds qui n’ont pas encore été parcouru. Nous appliquons components à ces nœuds un par un, components va par récursivité parcourir chaque voisin puis les voisin des voisins etc., jusqu’à avoir créé une liste de la composante connexe du nœud étudié.. Enfin, la fonction demandée connected_components_set est définie simplement en renvoyant un frozenset des résultats de la fonction connected_components.  
Question 3 : Cette question consistait à la définition d’une fonction get_path_with_power qui sera cruciale pour répondre au problème initial (calculer la puissance minimale nécessaire pour parcourir un trajet). En effet, cette fonction admet comme paramètre un trajet (caractérisé par son sommet de départ et son sommet d’arrivée) et un camion (caractérisé par sa puissance), et renvoie si oui ou non ce camion peut effectuer ce trajet (le cas échéant elle renvoie le trajet à effectuer avec). Pour définir cette fonction nous avons choisi de procéder de la manière suivante : nous créons une liste des sommets avec leur chemin du sommet de départ à celui-ci, à examiner et une liste qui correspond aux sommets déjà parcourus. Puis en partant du sommet de départ, on regarde tous les sommets accessibles dans ses voisins avec la puissance disponible, puis de même avec ces sommets accessibles et ainsi de suite jusqu’à arriver au sommet d’arrivée. Si les sommets ne sont pas reliés par des arrêtes de puissance inférieure à la puissance disponible, alors la fonction renvoie None. Nous avons choisi cette façon de réaliser cette fonction car elle permettait l’obtention de résultats satisfaisant en un temps assez court, ce qui correspondait à nos attentes.   
Complexité : Dans le pire des cas, la boucle while parcourt tous les sommets, de même pour la boucle for dans le pire des cas elle parcourt toutes les arrêtes. Ainsi on a une complexité de O( V*E ) , où V est le nombre de sommets et E le nombre d’arrêtes. Le reste des opérations étant en O(1). 
Question 4 : Ici, nous voulions reprendre en compte le paramètre de distance, en enlevant la valeur par défaut à 1 dans la fonction graph_from_file. Pour cela, nous avons simplement implémenté dans notre boucle if, un elif au cas où la distance soit précisée dans le fichier, qui ajoute cette distance au lieu du 1 par défaut. 
Question 5 : Dans le rendu intermédiaire nous avions modifié la question 3 pour prendre en compte la distance d, pour avoir le chemin le plus court. Après avoir testé la fonction get_path_with_power pour les routes nous avons remarqué qu’il était trop lent et donc nous l’avons modifié et ne prends désormais plus en compte la distance. 
Question 6 : La question 6 nous amène à répondre à notre problème, puisqu’il faut justement mettre en place la fonction min_power qui admet comme paramètre un trajet (caractérisé par son départ et son arrivée) et qui renvoie la puissance minimale qui est nécessaire pour réaliser ce trajet. Au vu des outils à notre disposition, la première idée a été de tester get_path_with_power pour le trajet en question pour chaque puissance, pour trouver la première puissance qui permettait de réaliser le trajet. Toutefois, les puissances étant assez élevées une telle répétition aurait été beaucoup trop chronophage et énergivore. Ainsi, nous nous sommes plutôt dirigés vers une recherche dichotomique, en commençant par tester les puissances de 2 pour trouver des premières bornes, à partir desquels nous avons réalisé une dichotomie, pour réduire les utilisations de get_path_with_power.  
En termes de complexité, la complexité de l’algorithme dichotomique est en O(log(p_min))  où p_min est la puissance minimale pour parcourir le trajet. La complexité de la question 6 est donc de O(V*E*log(p_min)) car à chaque réduction de l’intervalle par 2 on applique get_path_with_power. 
Question 10 : Pour calculer le temps nécessaire pour calculer la puissance nécessaire pour chaque trajets des fichiers routes, nous avons décidé, en suivant les indications, de mesurer pour 100 trajets aléatoirement choisis dans le fichier le temps nécessaire pour trouver la puissance minimale nécessaire, afin d’obtenir une durée moyenne que nous avons ensuite multiplié par le nombre de trajets dans le fichier.  
Après avoir essayé de faire tourner min_power dans une boucle de longueur 3 pour faire une moyenne sur route 1, le temps  est trop long pour être déterminé.  
Pour les autres routes, au vu du nombre de trajet je n’ai pas trouvé de solution pour deviner le temps qu’il dure pour ces fichiers. 
 
Question 12 : Pour essayer maintenant d’optimiser la fonction min_power, il nous fallait passer par un arbre couvrant de poids minimal. Nous devions donc définir une fonction qui, à partir d’un graphe renvoie l’arbre couvrant de poids minimal correspondant. Pour cela, nous sommes passés, en suivant les indications, par un algorithme de Kruskal en s’aidant d’un Union-Find. Voici un pseudo-code : 
- On crée un ensemble contenant tous les sommets, on trie les arrêtes du graphe par poids croissants. 
- On parcourt les arrêtes et on détermine si les 2 sommets de l’arrête possède le même représentant de leur classe. Pour créer les classes on se sert de Find, puis on fusionne les classes lorsque les deux sommets ne font pas partie de la même classe à l’aide de Union. 
- Find est un algorithme récursif qui permet de fixer un représentant à une composante connexe. Ainsi, tous les sommets de la composante connexe possèdent le même sommet pour “parent”. Ce qui nous permet de déterminer si on va créer un “cycle” dans l’algorithme de Kruskal. 
- Union est un algorithme qui prend deux composante connexe (deux sommets en réalité, mais qui sont dans des composantes connexes différentes) et va fusionner ces deux composantes connexes en fixant pour “parent” i.e., représentant des deux composantes connexes l’un des parents d’une des composantes connexes. 
De cette façon on obtient bien un arbre couvrant de poids minimal. 
 La complexité de l’algorithme de Kruskal est de O(E.log(E)) avec E qui est le nombre d’arrêtes du graphe.  
Au final, nous avons développé une deuxième version de l’algorithme de Kruskal qui est plus rapide, qui est en O(E) si on utilise un tri rapide. 
Question 14 : Ensuite, nous avons donc défini une fonction min_power_opti qui, en utilisant un arbre couvrant de puissance minimale, renvoie la puissance minimale nécessaire pour parcourir ce chemin. En effet, par définition de l’arbre couvrant de puissance minimale ne possède que le chemin nécessitant un minimum de puissance pour chaque trajet (on n’a gardé que les arrêtes avec les puissances les plus faibles qui ne formaient pas de boucle). Ainsi, on définit notre nouvelle fonction de la façon suivante : on crée notre arbre couvrant de puissance minimale, sur lequel on applique get_path_with_power (en mettant à la place de la puissance l’infini, on recherche juste le chemin), puis on cherche la puissance minimale nécessaire pour parcourir ce trajet en cherchant l’arrête de puissance maximale sur le trajet. L’avantage de cette fonction est qu'elle devrait être plus efficace et plus économe en temps.  
Question 15 : Justement, on s’intéresse au temps d’exécution de ce programme, avec un test analogue à celui que nous avons mis en œuvre à la question 10, afin de comparer ces deux temps pour vérifier ces supposées améliorations. Pour ce qui est de la complexité on trouve une complexité théorique de O(E) + O(V*E) puisque on applique Kruskal d’une part et d’autre part get_path_with_power sur un arbre couvrant de poids minimal, on a donc une complexité en O(E). 
Pour les temps d’exécutions on obtient pour des points au hasard en moyenne : 
•	Pour route 1 :  0.007701965514570475 
•	Pour route 2 : 8.365523535758257 
•	Pour route 3 :  27.003639843314886 
•	Pour route 4 : 39.58499291911721 
•	Pour route 5 : 4.62984899058938 
•	Pour route 6 : 25.360786821693182 
•	Pour route 7 : 25.19873669371009 
•	Pour route 8 : 29.143644496798515 
•	Pour route 9 : 58.91936598345637 
•	Pour route 10 : le fichier ne fonctionne pas ? 
 
Partie 2 : Optimisation de l’acquisition de camions 
Après avoir réussi à mettre en œuvre une fonction pouvant déterminer la puissance minimale pour parcourir un trajet donné, il s’agit maintenant de s’intéresser au problème initial qui est celui de l’optimisation de l’acquisition de camions par rapport au profit obtenu en couvrant chaque trajet. Nous avons pour cela un bon nombre d’outil que nous avons défini plus tôt et qui vont nous permettre de trouver une solution à ce problème. Tout d’abord, les paramètres à prendre en compte sont le budget de l’entreprise qui est donné, et l’utilité rapporté par chaque trajet (qui est donnée dans les fichiers routes). On considère donc ici que le profit correspond à la somme des utilités, sans les comparer aux coûts (on aurait pu par exemple considérer que le profit correspondait à la différence entre l’utilité et le coût du camion utilisé pour couvrir le trajet), on se place donc dans une version un peu simplifiée du problème où le coût n’a d’impact qu’en tant que limite (on ne peut pas dépasser le budget).  
Première idée : Algorithme glouton 
Notre première idée a été d’implémenter un algorithme glouton. L’idée est la suivante : on trie tous nos trajets par ordre décroissant d’utilité, puis en commençant par celui qui rapporte le plus d’utilité on regarde la puissance minimale nécessaire pour le couvrir. Ensuite, on cherche le camion le moins cher avec au moins cette puissance. Si le prix du camion est inférieur à ce qu’il nous reste dans notre budget, alors on achète ce camion et on l’attribue à ce chemin, sinon on passe au trajet suivant. On répète ce processus pour les trajets suivant jusqu’à ce que le budget soit épuisé ou que l’on ne puisse plus acheter aucun camion.  
Pour cela, on commence par créer le graphe, et récupérer les différents trajets donnés dans les fichiers routes correspondant. Pour cette dernière tâche, nous avons choisi de les récupérer sous la forme d’une liste de tuple comprenant le trajet (départ, arrivée) et l’utilité. De la même façon on récupère les informations portant sur les camions des fichiers trucks cette fois ci en récupérant une liste de tuples comprenant la puissance et le coût. Ensuite, on trie ces deux listes : la liste des trajets est triée par ordre décroissant en fonction de l’utilité, tandis que la liste des trajets est triée par ordre croissant d’utilité puis de coût.  On en profite pour créer une liste qui contiendra les camions à acheter ainsi que les trajets à leur attribuer, ainsi qu’une variable qui correspondra à la somme des utilités (qu’on appellera ici le profit). Enfin, pour chaque trajet en partant de celui qui rapporte l’utilité la plus importante on cherche la puissance minimale nécessaire pour le parcourir, le camion le moins cher ayant au moins cette puissance, que l’on achète et attribue à ce chemin à condition que notre budget le permettent. On répète ce processus pour tous les trajets, en ajoutant à chaque fois que l’on achète un camion le profit à notre variable qui comptabilise le profit total. 
Cet algorithme bien que fonctionnel reste relativement naïf. En effet, il n’est optimal ni par son temps d’exécution et sa complexité ni par ses résultats. Du côté de ses résultats, déjà, rien ne garantit l’optimalité de la solution qu’il trouve, l’algorithme favorise les trajets les plus rentables en termes d’utilité, mais sans prendre en compte les coûts (il est tout à fait possible que faire plusieurs trajets rapportant individuellement moins d’utilité soit en fait plus rentable qu’un seul trajet plus onéreux). De la même façon, sa complexité théorique n’est pas vraiment satisfaisante, puisque les opérations utilisées sont très nombreuses : d’abord des tris, puis notre fonction min_power relativement coûteuse en temps (que nous aurions toutefois pu remplacer par la version optimisée avec l’arbre couvrant de puissance minimale) que nous répétons pour chaque trajet (de l’ordre de 100 000). Nous avons donc vite admis que cette solution un peu simpliste ne pouvait pas être une solution optimale et adéquate pour notre problème. Par manque de temps nous n’avons malheureusement pas pu implémenter de nouvelles tentatives d’algorithme dans notre code, mais nous avons quand même pu commencer à réfléchir à d’autres solutions qui pourraient être plus satisfaisantes.  
